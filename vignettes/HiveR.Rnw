%\VignetteIndexEntry{HiveR: 2D and 3D Hive Plots for R}
%\VignetteDepends{RColorBrewer, grid, rgl, RFOC, bipartite, sna, xtable, mvbutils, FuncMap, lattice, reshape}
%\VignettePackage{HiveR}

\documentclass[10pt]{article}

\SweaveOpts{echo = T, pdf = T, eps = F, eval = T, keep.source = T, prefix.string = graphics/vig}
\usepackage{Sweave}
\setkeys{Gin}{width = 0.6\textwidth} % part of Sweave I believe; 0.8 is the default

\graphicspath{{./graphics/}}

\usepackage{mathpazo}
\usepackage{color}
\usepackage{graphicx}
\usepackage[margin = 2.0cm]{geometry}
\geometry{letterpaper}
\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
%\usepackage{pdflscape} % Use to turn the whole document or individual pages
\usepackage{fancyhdr}
\usepackage{xtab}

\usepackage[square, comma, numbers, sort&compress]{natbib} % allows grouping of references [1-4, 8]

\usepackage{ccaption} % Stuff to change the format of a figure caption
\captionnamefont{\bfseries\large}
\captiontitlefont{\bfseries\large}

\usepackage{hyperref, url}

\setlength{\belowcaptionskip}{10pt} % not part of ccaption

\renewcommand*\familydefault{\sfdefault} % Use if the base font of the document is to be sans serif

%%%%%     End of Configuration Stuff    %%%%%

<< getVersion, echo = FALSE >>=
desc <- packageDescription("HiveR")
vers <- paste("Version", desc$Version)
@

\title{The \texttt{HiveR} Package\\
\Sexpr{vers}\\}
\author{Bryan A. Hanson\\
\\
DePauw University\\
Department of Chemistry \& Biochemistry\\
Greencastle Indiana USA\\
\\
e-mail: \href{mailto:hanson@depauw.edu}{hanson@depauw.edu}\\
\\
\href{http://github.com/bryanhanson/HiveR}{github.com/bryanhanson/HiveR}\\
\href{http://CRAN.R-project.org/package=HiveR}{CRAN.R-project.org/package=HiveR}\\
}
\date{\today}

%%%%%%%%%
\begin{document}

\maketitle

This document describes some features of the \texttt{HiveR} package including current capabilities and future plans.  The current release contains a core set of functions for creating and drawing hive plots.  Additional features are contemplated.  There may well be bugs and features that can be improved.  Your comments are always welcome.

As with any \texttt{R} package, details on functions discussed below can be found by typing \texttt{?function\_name} in the \texttt{R} console after installing \texttt{HiveR}.  A complete list of functions available can be had by typing \texttt{?HiveR} and then at the bottom of the page that opens, click on the "index" link.

\section{Background, Inspiration and Motivation} %%%%%

\texttt{HiveR} was inspired by the concept of hive plots as developed by Martin Krzywinski at the Genome Science Center (\href{http://www.hiveplot.com/}{www.hiveplot.com}).  Hive plots are a reaction to "hair ball" style networks in which the layout of the network is arbitrary and hypersensitive to even small changes in the underlying network.  Hive plots are particularly useful for the discovery of emergent properties of networks.

The key innovation in a hive plot, compared to other means of graphically displaying network structure, is in how node information is handled.   Nodes are assigned to axes based upon qualitative or quantitative characteristics of the the node, for instance membership in a certain category, and the position of the node along the axis is based upon some quantitative characteristic of the node.  In a hive plot, edges are handled in a fairly standard way, but may be colored or have a width or weight which encodes an interesting value.  In creating a hive plot, one maps network parameters to the hive plot, and thus the process can be readily tuned to meet one's needs.  The mappable parameters are listed in Table~\ref{Mapping}, and the mapping is limited only by one's creativity and the particular knowledge domain.  Thus ecologists have their own measures of food webs, social network analysts have various measures describing interconnectedness etc.  An essential point is that mapping network parameters in this way results in a reproducible plot which is particularly well-suited for comparing related networks.  Comparison of "hair balls" is notoriously fraught with problems.

Krzywinski has an excellent paper detailing the features and virtues of hive plots and is a must-read.\cite{Krzywinski2011}  He notes the following virtues of hive plots:

\begin{itemize}
  \item Hive plots are rational in that only the structural properties of the network determine the layout.
  \item Hive plots are flexible and can be tuned to show interesting features.
  \item Hive plots are predictable since they arise from rules that map network features to plot features.
  \item Hive plots are robust to changes in the underlying network.
  \item Hive plots of different networks can be compared.
  \item Hive plots are transparent and practical.
  \item Plots of networks are generally complex and require some investment to understand.  Complexity scales well in a hive plot and details can be inspected.
\end{itemize}

For comparison, Suderman and Hallett have published a nice review of a wide range of other programs for visualizing biological networks though it is now slightly out of date.\cite{Suderman2007}

\begin{table}
\begin{center}
\begin{tabular}{|l|}
\hline
mappable hive plot parameters\\
\hline
Axis to which a node is assigned\\
Radius of a node\\
Color of a node\\
Size of a node\\
Color of an edge\\
Width or weight of an edge\\
\hline
\end{tabular}
\end{center}
\caption{Hive plot features that can be mapped to network parameters\label{Mapping}}
\end{table}

Inspired by the examples given by Kryzwinski in his materials on the web, I created the \texttt{R} package  \texttt{FuncMap} in December 2010.  This single function package maps the function calls made by an \texttt{R} package into 3 types: sources, which are functions that make only outgoing calls, sinks, which take only incoming calls, and managers, which do both.  Figure~\ref{FuncMap} shows an example of a plot made by \texttt{FuncMap}; this is a true hive plot.  In this plot, functions in a package are assigned to an axis by their role, and the radius is determined by the number of calls made or received by a function (which is the number of edges or degree of the node).  This is also the basis for the width of the edges.  In this plot, calls (edges) originating on the source axis are shown in green, while those originating on the manager axis are in blue.  By defintion, the sink axis only receives calls.

\texttt{HiveR} takes things quite a bit further.  \texttt{HiveR} is intended as an implementation of hive plots in \texttt{R}, not a port of linnet \emph{per se} (Krzywinski's program that draws hive plots, written in Perl).  As such, it does some things differently, and not all features are implemented (and they may or may not be in the future).  \texttt{HiveR} will draw 2D hive plots with 2-6 axes in a style close to that created by linnet.  However, \texttt{HiveR} adds value by making 3D, interactive plots possible when there are 4-6 axes.  These 3D plots were inspired by the ideas of VSEPR theory in chemistry:  the axes of these 3D plots are  arranged with tetrahedral, trigonal bipyramidal or octahedral geometries for 4-6 axes respectively (see Figure~\ref{VSEPR} and \href{https://secure.wikimedia.org/wikipedia/en/wiki/Vsepr}{wikipedia/VSEPR}).  Other differences are discussed below.

\begin{figure}
\begin{center}
\includegraphics[scale = 2]{VSEPR.pdf}
\end{center}
\caption{Idealized geometries according to VSEPR theory\label{VSEPR}}
\end{figure}

<< SetUp, echo = F, results = hide, eval = TRUE>>=
set.seed(123)
library(lattice) # these are only needed for the automatic vignette build, which occurs 
library(mvbutils) # in a clean environment
library(grid)
library(FuncMap)
library(HiveR)
library(sna)
library(xtable)
library(bipartite)
library(reshape)
if (!file.exists("graphics")) dir.create("graphics")
@

\begin{figure}
\begin{center}
<< FuncMapExample, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
fw <- foodweb(where = "package:lattice", plotting = FALSE)
ans <- FuncMap(fwb = fw, pkg = "lattice", method = "abs")
@
\end{center}
\caption{FuncMap for package lattice\label{FuncMap}}
\end{figure}

\section{\texttt{HiveR} Features} %%%%%

\subsection{Internal Storage}

\texttt{HiveR} stores the information needed to create a hive plot in a \texttt{HivePlotData} object which is an S3 class.  As an S3 class, this structure can be easily extended by the user to store additional information (though using that information as part of a hive plot would require more work).  Utilities are provided to summarize the contents of these objects and to check their integrity (functions \texttt{sumHPD} and \texttt{chkHPD} respectively).  The structure and content of a \texttt{HivePlotData} object is shown in Table~\ref{Struc}.


\begin{table}
\begin{center}

\begin{tabular}{|l|l|l|l|}
\hline
\emph{element} & \emph{(element)} & \emph{type}  & \emph{description}\cr
\hline
\$nodes & & data frame & Data frame of node properties \\
& \$id & int & Node identifier \\
& \$lab & chr & Node label \\
& \$axis & int & Axis to which node is assigned \\
& \$radius & num & Radius (position) of node along the axis \\
& \$size & num & Node size in pixels \\
& \$color & chr & Node color \\
\hline
\$edges & & data frame & Data frame of edge properties \\
& \$id1 & int & Starting node id \\
& \$id2 & int & Ending node id \\
& \$weight & num & Width of edge in pixels \\
& \$color & chr & Edge color \\
\hline
\$type & & chr & Type of hive (2D or 3D) \\
\hline
\$desc & & chr & Description of data \\
\hline
\$axis.cols & & chr & Colors for axes \\
\hline
- attr & & chr "HivePlotData" & The S3 class designation\\
\hline
\end{tabular}
\end{center}
\caption{The structure of a HivePlotData object\label{Struc}}
\end{table}



\subsection{Generation of Random Network Data Sets}

\texttt{HiveR} has the ability to generate random network data sets with between 2 and 6 axes, using function \texttt{ranHiveData}.  These are useful for testing and demonstration purposes and will be used in the examples below.  A data set has a type, either 2D or 3D.  Type 2D may have 2-6 axes and is plotted in a 2D window using \texttt{grid} graphics which are extremely fast.  Type 3D applies to 4-6 axes only and these hive plots are drawn in 3D using \texttt{rgl} and are interactive.  When using \texttt{ranHiveData} you can specify which type you desire.

\subsection{Built-in Data Sets}

\texttt{HiveR} contains two related 2D type data sets, \texttt{Safari} and \texttt{Arroyo}.  These plant-pollinator data sets give the number of visits for each plant-pollinator pair.  The \emph{E. coli} gene regulatory network is also included as a .dot file.  This data is discussed in Yan \emph{et. al.}\cite{Yan2010} but is based upon data in the RegulonDB.\cite{Gama2010} The version here was extended by Krzywinski and provided in the linnet package.  This .dot file can be processed into either a 2D or 3D type hive plot.  Each of these data sets are used in the examples below.

\subsection{Importing Real Data Sets}

The function \texttt{dot2HPD} will import files in .dot format and convert them to \texttt{HivePlotData} objects (see \href{https://secure.wikimedia.org/wikipedia/en/wiki/DOT\_language}{wikipedia/DOT\_language}).  This is done with the aid of two external files.  One contains information about how to map node labels to \texttt{HivePlotData} properties.  The other contains information about mapping edge properties.  This approach gives one a lot of flexibility to process the same graph into various hive plots.  This process is demonstrated later for the \emph{E. coli} data set.  Currently, only a very small set of the .dot standard is implemented and one should not expect any particular .dot file to process correctly.

\subsection{Modifying \texttt{HivePlotData} Sets}

Function \texttt{mineHPD} has several options for extracting information within an existing \texttt{HivePlotData} object and converting it to a modifed \texttt{HivePlotData} object.  Currently, there are three options, but more are easily added.  One option assigns the radius of a node based upon the number of edges connected to it (the degree).  Another assigns axes based upon whether a given node is a source node, manager node or sink node.  This latter option is designed to create hive plots similar to those featured by Krzywinski for the \emph{E. coli} data set, and is demonstrated later.  The final option removes any orphaned nodes (these have no edges).  In addition, function \texttt{manipAxis} can also be used to modify a \texttt{HivePlotData} object by scaling or inverting axes.

\subsection{Making Hive Plots}

In a hive plot, because the position of the node along an axis (the radius) is quantitative, the nodes can be plotted at their absolute value (native units), normalized to run between 0\ldots1, plotted by rank or by a combination of ranking and norming.  Some aspects of the plot that depend upon these options are shown in Table~\ref{Method}.  These different ways of plotting the same data often look dramatically different, and for a particular data set, some methods of plotting nodes may provide more insight.  Functions \texttt{plotHive} and \texttt{plot3dHive} have an argument \texttt{method} which controls node plotting on the fly; function \texttt{manipAxis} is used in the background and can be called independently if desired.

\bottomcaption{Comparison of methods for plotting node radii\label{Method}}

\begin{center}
\begin{xtabular}{| p{0.25\textwidth} | p{0.25\textwidth} | p{0.1\textwidth} | p{0.3\textwidth} |}
\hline
\emph{method} & \emph{axis length} & \emph{center hole}  & \emph{other} \\
\hline
\hline
native units (abs) & varies ($\propto no.\ nodes$) & asymmetric & nodes may overlap\\
\hline
ranked units (rank) & varies ($\propto rank(no.\ nodes)$) & circular & nodes evenly spaced (1, 2, 3 \dots) and don't overlap  \\
\hline
normed units (norm) & all equal & circular & nodes may overlap\\
\hline
ranked \& normed (ranknorm) & all equal & circular & nodes evenly spaced (1, 2, 3 \dots) and don't overlap \\
\hline
\end{xtabular}
\end{center}

\subsubsection{Type 2D Hive Plots}

Figures~\ref{HP2} shows a 2 axis hive plot using randomly generated data and the function \texttt{plotHive}.  Figure~\ref{HP3a} shows a hive plot of a random 3 axis network using absolute scaling; Figure~\ref{HP3r} shows the 3 axis example with the nodes displayed by rank and Figure~\ref{HP3n} the same data normed.  FIgure~\ref{HP5} shows a 5 axis example.  \texttt{plotHive} places axis number 1 at the top (vertical) except in the 2 axis case where it is on the right.  Nodes are drawn in these examples, however, drawing nodes is optional and the more nodes there are, the less likely you will want to draw them.  As these plots show, depending upon their size and radii, nodes may overlap.  The nodes "on top" will be those drawn last (also true of edges).  In some cases users may wish to sort the nodes and edges so that certain nodes and edges are drawn last and thus "show".  Nodes and edges with various characteristics can also be subsetted and recombined if simple sorting won't do the job.  This method is used in some of the examples which follow.

\begin{figure}

\begin{center}
<< HP2, fig = TRUE, echo = FALSE, width = 5, height = 2.5 >>=
hp2 <- ranHiveData(nx = 2)
plotHive(hp2, ch = 10)
@
\end{center}
\caption{A randomly generated hive plot with 2 axes (native units)\label{HP2}}
\end{figure}


\begin{figure}

\begin{center}
<< HP3a, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
hp3 <- ranHiveData(nx = 3)
plotHive(hp3, ch = 10)
@
\end{center}
\caption{A randomly generated hive plot with 3 axes (native units)\label{HP3a}}
\end{figure}


\begin{figure}

\begin{center}
<< HP3r, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
plotHive(hp3, method = "rank", ch = 1)
@
\end{center}
\caption{A randomly generated hive plot with 3 axes (nodes by rank)\label{HP3r}}
\end{figure}

\begin{figure}

\begin{center}
<< HP3n, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
plotHive(hp3, method = "norm", ch = 0.1)
@
\end{center}
\caption{A randomly generated hive plot with 3 axes (nodes normed)\label{HP3n}}
\end{figure}

\begin{figure}

\begin{center}
<< HP5, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
hp5 <- ranHiveData(nx = 5, allow.same = TRUE)
plotHive(hp5, ch = 10)
@
\end{center}
\caption{A randomly generated hive plot with 5 axes (native units; edges along the same axis permitted)\label{HP5}}
\end{figure}

\subsubsection{Type 3D Hive Plots}

With type 3D and 4 to 6 axes, plots are interactive and cannot be shown here.  See the help page for \texttt{plot3dHive} for an example you can run when have the package installed (\texttt{?plot3dHive}).  Note that \texttt{plot3dHive} has an argument \texttt{LA} which controls whether antialiasing is used when drawing the edges.  \texttt{LA} defaults to \texttt{FALSE} which plots quickly.  Further testing and optimization is needed, but \texttt{LA = TRUE} should probably be reserved for making final plots, as it is at least 20 times slower.

\subsubsection{Performance}

\texttt{HiveR} draws hive plots very quickly when using either \texttt{plotHive} or \texttt{plot3dHive}.  As of version 0.1-5, the bottlenecks holding \texttt{plot3dHive} back have been eliminated.  Figure~\ref{perf} shows the performance of this function on a MacBook Pro running OSX 10.6.8 using 8 Mb RAM and an Intel  i7 chip at 2 GHz.  As of version 0.1-6, speed improvements have been made to \texttt{plotHive} and Figure~\ref{perf2D} shows the performance on the same hardware.  These benchmarks were determined before byte compiling was turned on and so the performance is likely even better.

\begin{figure}

\begin{center}
\includegraphics{plot3dHive_performance.pdf}
\end{center}
\caption{Performance of plot3dHive\label{perf}}
\end{figure}

\begin{figure}

\begin{center}
\includegraphics{plotHive_performance.pdf}
\end{center}
\caption{Performance of plotHive\label{perf2D}}
\end{figure}

\subsection{Some Things to Keep in Mind} %%%%%

\begin{enumerate}
  \item As currently implemented in \texttt{HiveR}, hive plots are agnostic graphs in that they are not necessarily directed or undirected.  However, some of the functions actually do draw edges in a way that could readily be converted into a directed graph in the future.  For example, \texttt{plotHive} draws edges between axes 1 and 2 in a separate step from those starting on 2 and ending on 1.  This is so that the correct curvature of the splines is used, but it could be used to encode directionality.  Further, some options in \texttt{mineHPD} assume that the \texttt{HivePlotData} object represents a directed graph, and while \texttt{dot2HPD} currently doesn't distinguish between directed and non-directed graphs, it could in the future.
  
  \item linnet creates hive plots that are essentially parallel coordinate plots\cite{Wegman1990} that have been wrapped into a radial arrangement.  \texttt{HiveR} plots of type 2D are essentially the same thing.  As with any parallel coordinate plot, the order of the axes affects what you see.  With 2 or 3 axes this isn't a problem.  For 4-6 axes and type 2D, the user has to give some thought as to how to assign the axes.  One should assign the axes in a way that avoids edges jumping over or crossing an axis when using type 2D.  Edges should be arranged 1 $\rightarrow$ 2, 2 $\rightarrow$ 3, \ldots 5 $\rightarrow$ 6 but not 1 $\rightarrow$ 4 for example.  Function \texttt{sumHPD} with \texttt{chk.ax.jump = TRUE} will tell you if any edges cross.  For type 3D, one doesn't have to worry about this, but must guard against edges that start and end on the same axis or start and end on colinear axes.  \texttt{ranHiveData} takes care of these exceptions automatically.  By they way, these conditions don't cause errors, but they overdraw the axes and it doesn't look good.
  
  \item On the other hand, \texttt{HiveR} plots using type 3D are not a parallel coordinate plots.  For 4 axes plotted as a tetrahedron, any pair of axes are intrinsically next to each other and it is not possible for an edge to cross another axis.  For 5 and 6 axes, crossings are a potential problem but generally it is possible to connect axes in more combinations than for type 2D.  For instance, with 5 axes and type 2D, any one axis is between only 2 other axes, and hence can be connected to at most 2 other axes.  But for type 2D and 5 axes, an axis in the apical position can be connected to 3 other axes, and an axis in the equatorial position can be connected to 4 other axes (could use a diagram showing this).
  
  \item Some ideas for network parameters that might be mapped to node radii (see Table~\ref{Mapping}):
    \begin{enumerate}
      \item Ecology: see various species descriptors computed by function \texttt{specieslevel} in package \texttt{bipartite}.
      \item Social networks: see the section "Node-level indices" in the article describing package \texttt{sna}.\cite{Butts2008}  Briefly, degree, betweeness and closeness are the key ideas.
      \item See Table 1 in the article by Krzywinski.\cite{Krzywinski2011}
    \end{enumerate}
\end{enumerate}

\section{A Simple Example Using a Plant-Pollinator Network} %%%%%

\texttt{HiveR} currently contains the built-in data sets, \texttt{Safari} and \texttt{Arroyo} which provide a useful demonstration of \texttt{HiveR}.\footnote{Be warned: I am  not an ecologist and these data sets and plots are merely a demonstration of \texttt{HiveR}.}  These are plant-pollinator data sets which were derived from Vasquez and Simberloff, 2003 \cite{Vazquez2003}.  These describe two-trophic level systems that consist of almost exactly the same suite of plants and pollinators.  \texttt{Safari} is based upon observations of an undisturbed area, while \texttt{Arroyo} is from a nearby location grazed by cattle.  The original data is composed of plant-pollinator pairs and a count of visits for each pair.

Figures~\ref{PPN1} and \ref{PPN4} show two means of plotting \texttt{Safari} using package \texttt{bipartite}.\footnote{Note that we are using the data set \texttt{Safariland} from package \texttt{bipartite}; \texttt{Safari} was derived from \texttt{Safariland}.}  Figure~\ref{PPN1} is a simple diagram giving plant-pollinator visits as a gray scale heat map.  There are two parameters encoded here: the pairings and the number of visits (arguably, the dimensions of the matrix give the number of species involved as well).  Figure~\ref{PPN4} displays plants across the bottom and pollinators across the top.  The width of the connecting bands in the middle encodes the number of visits for a given plant-pollinator pair.  The width of the top or bottom panel for a species is the total number of visits in which that species participates.  Thus there are three parameters shown in this figure: the pairings, the total visits for a single species, and visits between a given pair.  This second plot makes it pretty clear that four plant-pollinator pairs have by far the most number of visits.

\begin{figure}

\begin{center}
<< PPN1, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
require(bipartite)
data(Safariland)
visweb(Safariland)
@
\end{center}
\caption{Safariland data set using visweb\label{PPN1}}
\end{figure}


\begin{figure}

\begin{center}
<< PPN4, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
plotweb(Safariland)
@
\end{center}
\caption{Safariland data set using plotweb\label{PPN4}}
\end{figure}

Another approach to presenting this network graphically would be to use function \texttt{gplot} in the very powerful social network analysis package \texttt{sna}.  \texttt{gplot} is flexible and has many options.  Figure~\ref{PPN5} shows one possible display of \texttt{Safari} (actually, \texttt{Safariland}).  In this plot, plant nodes are colored green and insect nodes red.  The width of the edges is proportional to the number of visits between a pair of species.  Figure~\ref{PPN6} shows the same data using a different layout algorithm, one which shows that there are actually two networks present (and which is not apparent from the hive plots below).  Edge width here is the same as before, but because high traffic pair nodes are close to each other, the connecting, wide edge looks a bit odd (clearly, one could experiment to improve this detail).

\begin{figure}

\begin{center}
<< PPN5, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
gplot(Safariland, gmode = "graph", edge.lwd = 0.05,
	vertex.col = c(rep("green", 9), rep("red", 27)),
	mode = "circle")
@
\end{center}
\caption{Safariland data set using gplot (mode = circle)\label{PPN5}}
\end{figure}

\begin{figure}

\begin{center}
<< PPN6, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
gplot(Safariland, gmode = "graph", edge.lwd = 0.05,
	vertex.col = c(rep("green", 9), rep("red", 27)))
@
\end{center}
\caption{Safariland data set using gplot (mode = Fruchterman-Reingold)\label{PPN6}}
\end{figure}

Figures~\ref{PPN2} and \ref{PPN3} show \texttt{Safari} and \texttt{Arroyo} respectively, using \texttt{plotHive} (instrinically type 2D since there are only 2 axes in the data set).  In these plots, plants are on one axis, and pollinators are on the other.  Each organism was assigned a radius on its axis based by calculating $d'$ using function \texttt{dfun} in package \texttt{bipartite}.  $d$' is an index of specialization; higher values mean the plant or pollinator is more specialized.\footnote{These plots use the absolute value of $d'$ for the node radii.}  Edge weights were assigned proportional to the square root of the normalized number of visits of a pollinator to a plant.  Thus the width of the edge drawn is an indication of the visitation rate.  The transformed number of visits was divided manually into 4 groups and used to assign edge colors ranging from white to red.  The redder colors represent greater numbers of visits, and the color-coding is comparable for each figure.  Thus both the edge color and the edge weight encode the same information.  It would of course be possible to encode an additional variables by changing either edge color or weight, or node size.  These plots show a rich amount of information not available from the more standard plots and show that the networks are fundamentally different:

\begin{itemize}
  \item The degree of specialization with each network is different.  A greater number of visits (wider, redder edges) occur between more specialized species (nodes at larger radii) in \texttt{Safari} than \texttt{Arroyo}.
  \item There are more plant species in \texttt{Arroyo}: the plant axis is longer.
  \item The huge number of visits encoded in red in \texttt{Safari} (the ungrazed site) is missing in \texttt{Arroyo}, which was an interesting aspect of the study.
\end{itemize}

\begin{figure}

\begin{center}
<< PPN2, fig = TRUE, echo = FALSE, width = 5, height = 2.5 >>=
data(Safari)
Safari$nodes$size <- 0.5
plotHive(Safari, ch = 0.1, axLabs = c("plants", "pollinators"), axLab.pos = c(0.15, 0.15), rot = c(-90, 90))
@
\end{center}
\caption{Safari data set using plotHive\label{PPN2}}
\end{figure}

\begin{figure}

\begin{center}
<< PPN3, fig = TRUE, echo = FALSE, width = 5, height = 2.5 >>=
data(Arroyo)
Arroyo$nodes$size <- 0.5
plotHive(Arroyo, ch = 0.1, axLabs = c("plants", "pollinators"), axLab.pos = c(0.15, 0.15), rot = c(-90, 90))
@
\end{center}
\caption{Arroyo data set using plotHive\label{PPN3}}
\end{figure}

\section{The \emph{E. coli} Gene Regulatory Network}

\texttt{HiveR} includes the \emph{E. coli} gene regulatory network, discussed in Yan \emph{et. al.}\cite{Yan2010} and based upon the RegulonDB\cite{Gama2010} and extended by Krzywinski.  It is contained in a file called \texttt{ecoli.dot} in the \texttt{extdata/E\_coli} directory.  It can be read in with \texttt{dot2HPD} and further processed with \texttt{mineHPD} as shown below.  \texttt{dot2HPD} relies on two external .csv files which tell the function how to map node and edge information in the .dot file to the \texttt{HivePlotData} object.  Tables~\ref{NI} and \ref{EI} show the contents of the files used in this case.  If you choose to draw the nodes, persistent nodes will be red and non-persistent nodes grey.  The type of edge (1\dots4) is also encoded by color. Gene pairs (edges) that are closer physically and genetically are colored gray $\rightarrow$ yellow $\rightarrow$ orange $\rightarrow$ red with red being the most related pairs.

<< NI, results = tex, echo = FALSE >>=
tab <- read.csv(file = system.file( "extdata", "E_coli", "NodeInst.csv", package = "HiveR"))
NI <- xtable(tab)
caption(NI) <- "Contents of NodeInst.csv"
label(NI) <- "NI"
print(NI, include.rownames = FALSE)
@

<< EI, results = tex, echo = FALSE >>=
tab <- read.csv(file = system.file( "extdata", "E_coli", "EdgeInst.csv", package = "HiveR"))
EI <- xtable(tab)
caption(EI) <- "Contents of EdgeInst.csv"
label(EI) <- "EI"
print(EI, include.rownames = FALSE)
@

First, read in the data set and process it using the two external files (this assumes your working directory is set to the folder with the relevant files).

<< E_coli_1a, echo = FALSE >>=
EC1 <- dot2HPD(file = system.file("extdata", "E_coli", "ecoli.dot", package = "HiveR"),
	node.inst = system.file("extdata", "E_coli", "NodeInst.csv", package = "HiveR"),
	edge.inst = system.file( "extdata", "E_coli", "EdgeInst.csv", package = "HiveR"),
	desc = "E coli gene regulatory network (Yan et al PNAS vol 107 pg 9186 (2010)) ",
	axis.cols = rep("grey", 3))
@

<< E_coli_1b, eval = FALSE >>=
EC1 <- dot2HPD(file = "ecoli.dot",
	node.inst = "NodeInst.csv",
	edge.inst = "EdgeInst.csv",
	desc = "E coli gene regulatory network (Yan et al PNAS vol 107 pg 9186 (2010)) ",
	axis.cols = rep("grey", 3))
@

Next, assign the node radius based upon the edge degree.  Then assign the nodes to axes based upon their role as source, manager or sink.  Finally, let's remove any orphaned nodes (nodes that have no edges).  Note that if desired, \texttt{> sumHPD(EC3, chk.orphan.node = TRUE)} could be used to preview the list of orphans.

<< E_coli_1c >>=
EC2 <- mineHPD(EC1, option = "rad <- tot.edge.count")

EC3 <- mineHPD(EC2, option = "axis <- source.man.sink")

EC4 <- mineHPD(EC3, option = "remove orphans")
@

If you try to plot this now (\texttt{> plotHive(EC4)}), you encounter an error because two edges start and end on the same node (so they are on the same axis with the same radius).  This would result in an edge length of zero, which is not possible (see \texttt{?sumHPD} for more details).  We can use \texttt{sumHPD} to find out where the problem is.  It turns out that two nodes are common to both problem edges.  To avoid this problem, we'll nudge one node to a different value.

<< E_coli_1d >>=
sumHPD(EC4, chk.sm.pt = TRUE)

EC4$nodes$radius[1149] <- 9.5
@

Finally, we'll need to organize the edge list so that the reddest edges are drawn last, which will make the plots a bit easier to interpret (see later for another approach).

<< E_coli_1e >>=
edges <- EC4$edges
gray_edges <- subset(edges, color == "gray")
yel_edges <- subset(edges, color == "yellow")
or_edges <- subset(edges, color == "orange")
red_edges <- subset(edges, color == "red")
edges <- rbind(gray_edges, yel_edges, or_edges, red_edges)
EC4$edges <- edges
@

Now we're ready to plot!

Figures~\ref{E_coli_2}, \ref{E_coli_3}, and \ref{E_coli_4} shows the hive plot of this network using methods \texttt{absolute}, \texttt{rank} and \texttt{norm} respectively.  Each plot takes about 10 seconds to draw. Figure~\ref{E_coli_5} is the same as Figure~\ref{E_coli_3} but adds the nodes: red nodes are persistent meaning they are common to a group of about 200 bacterial species.  When plotting with \texttt{method = "rank"} (as here) each gene gets a unique node (the other two method overlap nodes if more than one is present, and thus the last node plotted determines the color).  With this many nodes, overplotting is a problem, so we shrank the node size and sorted the nodes so that the red nodes were drawn last (a strategy documented in more detail in an upcoming example).  Another approach might be to expand the axis length, but that's probably not realistic: there are 1,274 nodes on this axis.  Note that the manager axis nodes all appear to be persistent (red).

\begin{figure}
\begin{center}
<< E_coli_2, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
plotHive(EC4, dr.nodes = FALSE, ch = 20, axLabs = c("source", "sink", "manager"),
axLab.pos = c(40, 75, 35), axLab.gpar = gpar(fontsize = 10, col = "white", lwd = 2),
arrow = c("degree", 30, 60, 120, 50))
@
\end{center}
\caption{Hive plot of \emph{E. coli} gene regulatory network (native node units)\label{E_coli_2}}
\end{figure}

\begin{figure}
\begin{center}
<< E_coli_3, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
plotHive(EC4, dr.nodes = FALSE, method = "rank", ch = 100, axLabs = c("source", "sink", "manager"),
axLab.pos = c(100, 125, 180), axLab.gpar = gpar(fontsize = 10, col = "white"))
@
\end{center}
\caption{Hive plot of \emph{E. coli} gene regulatory network (nodes ranked)\label{E_coli_3}}
\end{figure}

\begin{figure}
\begin{center}
<< E_coli_4, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
plotHive(EC4, dr.nodes = FALSE, method = "norm", ch = 0.1, axLabs = c("source", "sink", "manager"),
axLab.pos = c(0.1, 0.2, 0.2), axLab.gpar = gpar(fontsize = 10, col = "white"))
@
\end{center}
\caption{Hive plot of \emph{E. coli} gene regulatory network (nodes normed)\label{E_coli_4}}
\end{figure}

\begin{figure}
\begin{center}
<< E_coli_5, fig = TRUE, echo = FALSE, width = 5, height = 5 >>=
EC4a <- EC4
EC4a$nodes$size <- EC4a$nodes$size * 0.1
nodes <- EC4a$nodes
nodes <- sort_df(nodes, vars = "color")
EC4a$nodes <- nodes
plotHive(EC4a, dr.nodes = TRUE, method = "rank", ch = 100, axLabs = c("source", "sink", "manager"),
axLab.pos = c(100, 125, 180), axLab.gpar = gpar(fontsize = 10, col = "white"))
@
\end{center}
\caption{Hive plot of \emph{E. coli} gene regulatory network (nodes ranked)\label{E_coli_5}}
\end{figure}


\section{Further Explorations of the \emph{E. coli} Network}

In this section we'll demonstrate some slightly more advanced manipulations of the \emph{E. coli} network data, including how one can make \emph{hive panels} which are useful in comparing multiple hive plots.  In some of the manipulations below, data types are coerced away from the definition found in a \texttt{HivePlotData} object and must be restored.  It might be helpful to study the description of the required structure at \texttt{?HPD}.

First, we are going to re-code some of the information in the network.  In the original publication, nodes were classified as either persistent or non-persistent.  This classification was based upon comparison of the \emph{E. coli} genome to roughly 200 other bacterial genomes.  A gene was considered persistent if it was present in these other genomes, otherwise it is non-persistent and unique to \emph{E. coli}.  In our processing above, genes (nodes) that are persistent are red, while non-persistent nodes are black.  We can use the existing axis assignments, based upon role as source, manager or sink, along with the persistence information, to display the network taking this information into account.  In principle, there are six possible combinations: (persistent, non-persistent) x (source, manager, sink).  However, it turns out that one of these combinations doesn't exist (persistent sources), so we'll re-code this information into a five axis hive plot.\footnote{Not only am I not an ecologist, I am not a molecular biologist.  I have no idea if this analysis is actually worthwhile, I just thought it would be interesting to see these relationships.  Plus, it also permits further manipulations to be demonstrated.}  Here's the first step, starting from where we left off above:

<< E_coli_5 >>=
EC5 <- EC4
nodes2 <- nodes <- EC5$nodes
nn <- length(nodes$axis)
#
for (n in 1:nn) { 
	if ((nodes$axis[n] == 1) & (nodes$color[n] == "black")) nodes2$axis[n] <- 1
	if ((nodes$axis[n] == 2) & (nodes$color[n] == "black")) nodes2$axis[n] <- 2
	if ((nodes$axis[n] == 3) & (nodes$color[n] == "black")) nodes2$axis[n] <- 3
	if ((nodes$axis[n] == 2) & (nodes$color[n] == "red")) nodes2$axis[n] <- 4
	if ((nodes$axis[n] == 3) & (nodes$color[n] == "red")) nodes2$axis[n] <- 5
	}
#		
# Final assembly & checking...
#
nodes2$axis <- as.integer(nodes2$axis)
EC5$nodes <- nodes2
EC5$axis.cols <- rep("gray", 5) # we added 2 more axes!
#
sumHPD(EC5)
# sumHPD(EC5, chk.all = TRUE) # not run, the output is long
@

With \texttt{sumHPD}, one can use \texttt{chk.all = TRUE} which runs some additional checks on the data (see \texttt{?sumHPD} for full details).  Had we done so in this case, we would find that some edges start and stop on the manager axis; perhaps you noticed this earlier.  These are managers that call other managers.  Also, somewhat miraculously, there are no edges crossing axes in this particular partitioning of nodes (\texttt{chk.all} also looks for this condition).  In the basic summary that we did run, axis five has only one node on it.  This will plot fine except for the case where one uses \texttt{method = "norm"} which will fail because to normalize the node radii, there has to be more than one radius value.  To fix this, we'll add in a phantom, invisible node to anchor axis five as follows:

<< E_coli_6>>=
EC6 <- EC5
tmp <- data.frame(id = 1379, lab = "axis_5_anchor",
	axis = 5, radius = 1, size = 1, color = "grey")
EC6$nodes <- rbind(EC6$nodes, tmp)
#
# Clean up, re-size nodes, sort nodes so
# persistent (red) ones are drawn last & check:
#
EC6$nodes$axis <- as.integer(EC6$nodes$axis)
EC6$nodes$id <- as.integer(EC6$nodes$id)
EC6$nodes$size <- EC6$nodes$size * 0.1
#
nodes <- EC6$nodes
nodes <- sort_df(nodes, vars = "color")
EC6$nodes <- nodes
#
sumHPD(EC6)
@

Next, we are going to copy the current version of the network (EC6) and scale the axes of the copy, because the summary above shows that the axis lengths are quite different and the shorter axes will be nearly invisible if we don't scale them up at least a bit.

<< E_coli_7 >>=
EC7 <- manipAxis(EC6, method = "scale", action = c(1, 10, 1, 10, 10))
sumHPD(EC6)
@

Now we'll make a hive panel showing this same network displayed using different methods.  The code follows; it uses the \texttt{grid} graphics systems and associated viewport concepts to create a 2 x 2 hive panel.  The resulting hive panel is Figure~\ref{E_coli_8}.

\setkeys{Gin}{width = 0.7\textwidth}

\begin{figure}
\begin{center}
<< E_coli_8, fig = TRUE, width = 8, height = 8, echo = TRUE >>=
vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)
#
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))
#
pushViewport(vplayout(1, 1)) # upper left plot
plotHive(EC6, ch = 20, np = FALSE)
popViewport(2)
#
pushViewport(vplayout(1, 2)) # upper right plot
plotHive(EC7, ch = 0.1, method = "norm", np = FALSE,
	axLabs = c("non-persistent\nsource", "non-persistent\nsink",
	"non-persistent\nmanager", "persistent\nmanager", "persistent \nsink"),
	axLab.pos = rep(0.2, 5), axLab.gpar = gpar(fontsize = 10, col = "white"),
	rot = c(0, 72, 0, 0, -72), anNode.gpar = gpar(fontsize = 10, col = "pink", lwd = 0.5),
	anNodes = system.file("extdata", "E_coli", "NodeLabels.csv", package = "HiveR"))
popViewport(2)
#
pushViewport(vplayout(2,1)) # lower left plot
plotHive(EC7, ch = 100, method = "rank", np = FALSE)
popViewport(2)
#
pushViewport(vplayout(2,2)) # lower right plot
plotHive(EC7, ch = 20, np = FALSE)
@
\end{center}
\caption{Hive panel showing \emph{E. coli} regulatory network with different display options \label{E_coli_8}}
\end{figure}

Finally, the lower right hive plot in Figure~\ref{E_coli_8} can serve as a starting point for teasing out even more information.  Instead of drawing all the edges in one hive plot, we'll make a hive panel showing each edge category in a different panel.  The steps are given below; the resulting panel is Figure~\ref{E_coli_9} (the steps to produce the panel are not shown here, but are the same as before).

<< E_coli_9 >>=
EC11 <- EC10 <- EC9 <- EC8 <- EC7

edges <- EC7$edges
gray_edges <- subset(edges, color == "gray")
yel_edges <- subset(edges, color == "yellow")
or_edges <- subset(edges, color == "orange")
red_edges <- subset(edges, color == "red")

EC8$edges <- gray_edges
EC9$edges <- yel_edges
EC10$edges <- or_edges
EC11$edges <- red_edges
@

\begin{figure}
\begin{center}
<< E_coli_10, fig = TRUE, width = 8, height = 8, echo = FALSE >>=
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))
#
pushViewport(vplayout(1, 1))
plotHive(EC8, ch = 20, np = FALSE)
popViewport(2)
#
pushViewport(vplayout(1, 2))
plotHive(EC9, ch = 20, np = FALSE)
popViewport(2)
#
pushViewport(vplayout(2,1))
plotHive(EC10, ch = 20, np = FALSE)
popViewport(2)
#
pushViewport(vplayout(2,2))
plotHive(EC11, ch = 20, np = FALSE)
@
\end{center}
\caption{Hive panel showing \emph{E. coli} regulatory network with edges encoded by genetic distance (Red edges are the closest; each set of edges plotted separately) \label{E_coli_9}}
\end{figure}

\section{Comparison to linnet} %%%%%

linnet (for linear networks) is the Perl program written by Krzywinski that draws hive plots.  Here are some notes about how \texttt{HiveR} compares to linnet.

\begin{enumerate}
  \item To show more information, in linnet one can clone an axis to specifically show connections that would start and end on the same axis (if it isn't cloned).  Cloned axes appear a bit on either side of where the original axis would have been.  In \texttt{HiveR}, the same notion can be implemented, but rather than clone an existing axis, one can simply add a new axis based upon some property of the system.  Alternatively, for 2D hive plots, \texttt{HiveR} is able to show edges that start and end on the same axis (linnet does not do this).
  \item No segmentation of an axis is currently possible with \texttt{HiveR}.
  \item linnet uses bezier curves to create the edges; \texttt{HiveR} uses splines with a single control point.
\end{enumerate}

\section{Features Planned and Under Consideration} %%%%%

\begin{enumerate}
  \item Add the ability to subtract 2 hive plots and display the result.
  \item Set up animations for the 3D mode.  Perhaps include the possibility of running two animations of related hives side by side.
  \item Set up a mechanism to automatically permute the axes in 3D mode when nx = 5 or 6 so that the best option can be selected.  Might also be worth doing in 2D mode for 4-6 axes, except in this case it's not a question of how you display but how you import the data. Wegman\cite{Wegman1990} has a formula describing all possible combinations that would be needed.
  \item Set up mouse controls in 3D mode.
  \item Smallish items
  	\begin{enumerate}
		\item The current 3D spline calculation produces an asymmetric spline.  It could be made symmetric.
		\item The current splines could be converted to Bezier curves.
  		\item  Could add line type as an edge parameter.  This might be simple, or not.		
	\end{enumerate}
\end{enumerate}

\section{Acknowledgements} %%%%%

Naturally, I thank Martin Krzywinski for numerous helpful communications.  I also appreciate helpful discussions on gene ontology concepts with my colleague Professor Chet Fornari.

\begin{flushleft}
\bibliographystyle{ieeetr} % Cause refs to be numbered and collected in order used
\addcontentsline{toc}{section}{References}
\bibliography{HiveR}
\end{flushleft}

\end{document}
